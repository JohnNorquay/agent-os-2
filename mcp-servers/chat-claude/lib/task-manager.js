/**
 * Task Manager
 * Manages delegated tasks, their status, and results
 */

import { readFile, writeFile, mkdir } from 'fs/promises';
import { join, dirname } from 'path';
import { existsSync } from 'fs';

export class TaskManager {
  constructor(projectRoot) {
    this.projectRoot = projectRoot;
    this.tasks = new Map(); // In-memory task storage
    this.resultsDir = join(projectRoot, '.agent-os', 'delegated-results');
  }

  /**
   * Initialize task manager
   */
  async initialize() {
    // Ensure results directory exists
    try {
      if (!existsSync(this.resultsDir)) {
        await mkdir(this.resultsDir, { recursive: true });
      }
    } catch (error) {
      console.error('Error creating results directory:', error);
    }
  }

  /**
   * Add a new task
   */
  addTask(task) {
    const taskRecord = {
      ...task,
      status: 'pending',
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };

    this.tasks.set(task.task_id, taskRecord);
    return taskRecord;
  }

  /**
   * Update task status
   */
  updateTask(task_id, updates) {
    const task = this.tasks.get(task_id);
    if (!task) {
      throw new Error(`Task ${task_id} not found`);
    }

    const updatedTask = {
      ...task,
      ...updates,
      updated_at: new Date().toISOString()
    };

    this.tasks.set(task_id, updatedTask);
    return updatedTask;
  }

  /**
   * Get task by ID
   */
  getTask(task_id) {
    return this.tasks.get(task_id);
  }

  /**
   * Get all tasks
   */
  getAllTasks(statusFilter = null) {
    const allTasks = Array.from(this.tasks.values());

    if (statusFilter) {
      return allTasks.filter(task => task.status === statusFilter);
    }

    return allTasks;
  }

  /**
   * Store task result to file
   */
  async storeResult(task_id, content, filename = null) {
    const task = this.getTask(task_id);
    if (!task) {
      throw new Error(`Task ${task_id} not found`);
    }

    // Generate filename if not provided
    if (!filename) {
      const timestamp = new Date().toISOString().split('T')[0];
      const sanitizedId = task_id.replace(/[^a-z0-9-]/gi, '-').toLowerCase();
      filename = `${timestamp}-${sanitizedId}.md`;
    }

    const filepath = join(this.resultsDir, filename);

    // Create result document with metadata
    const resultDoc = `# ${task.description}

**Task ID**: ${task_id}
**Type**: ${task.task_type}
**Status**: ${task.status}
**Created**: ${task.created_at}
**Completed**: ${task.metadata?.completed_at || 'N/A'}

---

${content}

---

*Generated by Chat Claude via Agent-OS 2.0 parallel workflow system*
`;

    await writeFile(filepath, resultDoc, 'utf8');

    // Update task with result filepath
    this.updateTask(task_id, {
      result_filepath: filepath,
      result_filename: filename
    });

    return filepath;
  }

  /**
   * Read task result from file
   */
  async getResult(task_id) {
    const task = this.getTask(task_id);
    if (!task) {
      throw new Error(`Task ${task_id} not found`);
    }

    if (!task.result_filepath) {
      return null;
    }

    try {
      const content = await readFile(task.result_filepath, 'utf8');
      return content;
    } catch (error) {
      console.error('Error reading result file:', error);
      return null;
    }
  }

  /**
   * Get current spec directory for storing results
   */
  async getCurrentSpecDir() {
    const specsDir = join(this.projectRoot, '.agent-os', 'specs');

    try {
      // Find most recent spec directory
      const { readdir } = await import('fs/promises');
      const entries = await readdir(specsDir, { withFileTypes: true });

      const specDirs = entries
        .filter(entry => entry.isDirectory())
        .map(entry => entry.name)
        .sort()
        .reverse();

      if (specDirs.length > 0) {
        const currentSpec = join(specsDir, specDirs[0], 'delegated-results');

        // Create delegated-results directory in current spec
        if (!existsSync(currentSpec)) {
          await mkdir(currentSpec, { recursive: true });
        }

        return currentSpec;
      }
    } catch (error) {
      console.error('Error finding current spec:', error);
    }

    // Fallback to main delegated-results directory
    return this.resultsDir;
  }

  /**
   * Store result in current spec directory
   */
  async storeResultInSpec(task_id, content, filename = null) {
    const specResultsDir = await this.getCurrentSpecDir();
    const originalResultsDir = this.resultsDir;

    // Temporarily change results directory
    this.resultsDir = specResultsDir;

    try {
      const filepath = await this.storeResult(task_id, content, filename);
      return filepath;
    } finally {
      // Restore original results directory
      this.resultsDir = originalResultsDir;
    }
  }

  /**
   * Delete task
   */
  deleteTask(task_id) {
    return this.tasks.delete(task_id);
  }

  /**
   * Get task statistics
   */
  getStats() {
    const allTasks = this.getAllTasks();

    return {
      total: allTasks.length,
      pending: allTasks.filter(t => t.status === 'pending').length,
      in_progress: allTasks.filter(t => t.status === 'in_progress').length,
      completed: allTasks.filter(t => t.status === 'completed').length,
      failed: allTasks.filter(t => t.status === 'failed').length
    };
  }
}
